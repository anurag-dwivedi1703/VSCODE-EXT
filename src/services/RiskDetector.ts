/**
 * RiskDetector.ts
 * 
 * Scans the workspace for potential risks including:
 * - Hardcoded secrets (API keys, passwords, tokens)
 * - Unprotected .env files
 * - Files with "DO NOT MODIFY" markers
 * - Global state patterns that could cause issues
 * - Security vulnerabilities
 * - Performance anti-patterns
 * 
 * This feeds into the constitution to create forbidden patterns
 * that agents must avoid.
 */

import * as fs from 'fs';
import * as path from 'path';
import {
    DetectedRisk,
    ForbiddenPattern,
    EnforcementLevel
} from '../engine/ConstitutionSchema';

// ============================================
// SECRET PATTERNS
// ============================================

/**
 * Patterns that indicate potential secrets
 */
const SECRET_PATTERNS: Array<{
    pattern: RegExp;
    name: string;
    severity: EnforcementLevel;
}> = [
    // API Keys
    { pattern: /['"]?api[_-]?key['"]?\s*[:=]\s*['"][a-zA-Z0-9_-]{20,}['"]/gi, name: 'API Key', severity: 'strict' },
    { pattern: /['"]?apikey['"]?\s*[:=]\s*['"][a-zA-Z0-9_-]{20,}['"]/gi, name: 'API Key', severity: 'strict' },
    { pattern: /AKIA[0-9A-Z]{16}/g, name: 'AWS Access Key', severity: 'strict' },
    { pattern: /sk-[a-zA-Z0-9]{20,}/g, name: 'OpenAI API Key', severity: 'strict' },
    { pattern: /sk-ant-[a-zA-Z0-9-]{40,}/g, name: 'Anthropic API Key', severity: 'strict' },
    { pattern: /AIza[0-9A-Za-z_-]{35}/g, name: 'Google API Key', severity: 'strict' },
    { pattern: /ghp_[a-zA-Z0-9]{36}/g, name: 'GitHub Token', severity: 'strict' },
    { pattern: /gho_[a-zA-Z0-9]{36}/g, name: 'GitHub OAuth Token', severity: 'strict' },
    
    // Passwords
    { pattern: /['"]?password['"]?\s*[:=]\s*['"][^'"]{8,}['"]/gi, name: 'Hardcoded Password', severity: 'strict' },
    { pattern: /['"]?passwd['"]?\s*[:=]\s*['"][^'"]{8,}['"]/gi, name: 'Hardcoded Password', severity: 'strict' },
    { pattern: /['"]?secret['"]?\s*[:=]\s*['"][^'"]{8,}['"]/gi, name: 'Hardcoded Secret', severity: 'strict' },
    
    // Tokens
    { pattern: /['"]?token['"]?\s*[:=]\s*['"][a-zA-Z0-9_-]{20,}['"]/gi, name: 'Token', severity: 'strict' },
    { pattern: /['"]?auth[_-]?token['"]?\s*[:=]\s*['"][a-zA-Z0-9_-]{20,}['"]/gi, name: 'Auth Token', severity: 'strict' },
    { pattern: /['"]?bearer['"]?\s*[:=]?\s*['"]?[a-zA-Z0-9_-]{20,}['"]?/gi, name: 'Bearer Token', severity: 'strict' },
    
    // Private Keys
    { pattern: /-----BEGIN (?:RSA |EC |OPENSSH )?PRIVATE KEY-----/g, name: 'Private Key', severity: 'strict' },
    { pattern: /-----BEGIN PGP PRIVATE KEY BLOCK-----/g, name: 'PGP Private Key', severity: 'strict' },
    
    // Database
    { pattern: /mongodb\+srv:\/\/[^:]+:[^@]+@/gi, name: 'MongoDB Connection String', severity: 'strict' },
    { pattern: /postgres:\/\/[^:]+:[^@]+@/gi, name: 'PostgreSQL Connection String', severity: 'strict' },
    { pattern: /mysql:\/\/[^:]+:[^@]+@/gi, name: 'MySQL Connection String', severity: 'strict' },
    { pattern: /redis:\/\/[^:]+:[^@]+@/gi, name: 'Redis Connection String', severity: 'strict' },
    
    // JWT
    { pattern: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/g, name: 'JWT Token', severity: 'warning' },
];

// ============================================
// SACRED FILE PATTERNS
// ============================================

/**
 * Patterns indicating files that shouldn't be modified
 */
const SACRED_FILE_MARKERS = [
    'DO NOT MODIFY',
    'DO NOT EDIT',
    'AUTO-GENERATED',
    'GENERATED CODE',
    '@generated',
    'THIS FILE IS AUTOMATICALLY GENERATED',
    'DO NOT CHANGE',
    'MACHINE GENERATED',
    'Generated by',
];

// ============================================
// RISKY PATTERNS
// ============================================

/**
 * Code patterns that could cause issues
 */
const RISKY_CODE_PATTERNS: Array<{
    pattern: RegExp;
    name: string;
    description: string;
    severity: EnforcementLevel;
    suggestion?: string;
}> = [
    // Global state
    {
        pattern: /(?:let|var)\s+\w+\s*=\s*(?:\{|\[)/g,
        name: 'Global mutable state',
        description: 'Global mutable variables can cause race conditions',
        severity: 'warning',
        suggestion: 'Use module-level constants or encapsulate in a class'
    },
    
    // Eval
    {
        pattern: /\beval\s*\(/g,
        name: 'Eval usage',
        description: 'eval() is dangerous and can lead to code injection',
        severity: 'strict',
        suggestion: 'Use safer alternatives like JSON.parse() or Function constructor'
    },
    
    // innerHTML
    {
        pattern: /\.innerHTML\s*=/g,
        name: 'innerHTML assignment',
        description: 'Direct innerHTML assignment can cause XSS vulnerabilities',
        severity: 'warning',
        suggestion: 'Use textContent, createElement, or a sanitizer library'
    },
    
    // SQL Injection risk
    {
        pattern: /\$\{.*\}.*(?:SELECT|INSERT|UPDATE|DELETE|DROP|ALTER)/gi,
        name: 'SQL template literal',
        description: 'String interpolation in SQL queries can lead to injection',
        severity: 'strict',
        suggestion: 'Use parameterized queries or an ORM'
    },
    
    // Console in production
    {
        pattern: /console\.(log|debug|info|warn|error)\(/g,
        name: 'Console statement',
        description: 'Console statements should not be in production code',
        severity: 'suggestion',
        suggestion: 'Use a proper logging library'
    },
    
    // Debugger
    {
        pattern: /\bdebugger\b/g,
        name: 'Debugger statement',
        description: 'Debugger statements should not be committed',
        severity: 'strict',
        suggestion: 'Remove debugger statements before committing'
    },
    
    // TODO/FIXME
    {
        pattern: /\/\/\s*(TODO|FIXME|HACK|XXX):/gi,
        name: 'TODO/FIXME comment',
        description: 'Unresolved TODO or FIXME comments',
        severity: 'suggestion',
        suggestion: 'Address or create a ticket for tracking'
    },
    
    // Async without await
    {
        pattern: /async\s+(?:function\s+\w+|\(\w*\)|\w+)\s*(?:=>|{)(?![^}]*await)/g,
        name: 'Async without await',
        description: 'Async function without await might be unnecessary',
        severity: 'suggestion',
        suggestion: 'Remove async if not needed or add await'
    },
    
    // Hardcoded URLs
    {
        pattern: /['"]https?:\/\/(?:localhost|127\.0\.0\.1|0\.0\.0\.0)/gi,
        name: 'Hardcoded localhost URL',
        description: 'Hardcoded localhost URLs will fail in production',
        severity: 'warning',
        suggestion: 'Use environment variables for URLs'
    },
    
    // setTimeout/setInterval with string
    {
        pattern: /(?:setTimeout|setInterval)\s*\(\s*['"`]/g,
        name: 'setTimeout/setInterval with string',
        description: 'Using string argument is like eval and is dangerous',
        severity: 'strict',
        suggestion: 'Use a function instead of a string'
    },
    
    // Any type
    {
        pattern: /:\s*any\b/g,
        name: 'Explicit any type',
        description: 'Using any defeats TypeScript type safety',
        severity: 'warning',
        suggestion: 'Use a proper type, unknown, or a type guard'
    },
    
    // @ts-ignore
    {
        pattern: /@ts-(?:ignore|nocheck)/g,
        name: 'TypeScript suppression',
        description: 'TypeScript suppression comments hide potential issues',
        severity: 'warning',
        suggestion: 'Fix the type error instead of suppressing it'
    },
];

// ============================================
// RISK DETECTOR CLASS
// ============================================

export class RiskDetector {
    private workspaceRoot: string;
    
    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
    }
    
    /**
     * Perform full risk scan
     */
    async scan(): Promise<DetectedRisk[]> {
        const risks: DetectedRisk[] = [];
        
        // Scan source files
        const sourceRisks = await this.scanSourceFiles();
        risks.push(...sourceRisks);
        
        // Check for .env files
        const envRisks = this.checkEnvFiles();
        risks.push(...envRisks);
        
        // Check .gitignore
        const gitignoreRisks = this.checkGitignore();
        risks.push(...gitignoreRisks);
        
        // Deduplicate similar risks
        return this.deduplicateRisks(risks);
    }
    
    /**
     * Generate forbidden patterns from detected risks
     */
    generateForbiddenPatterns(risks: DetectedRisk[]): ForbiddenPattern[] {
        const patterns: ForbiddenPattern[] = [];
        const seenPatterns = new Set<string>();
        
        for (const risk of risks) {
            // Skip if we already have a similar pattern
            const key = `${risk.type}-${risk.description}`;
            if (seenPatterns.has(key)) {
                continue;
            }
            seenPatterns.add(key);
            
            // Convert risk to forbidden pattern
            patterns.push({
                id: risk.id,
                description: risk.description,
                reason: this.getReasonForRisk(risk),
                enforcement: risk.severity,
                autoDetected: true,
                suggestion: risk.suggestion,
                appliesTo: risk.file ? [path.extname(risk.file)] : undefined
            });
        }
        
        return patterns;
    }
    
    /**
     * Scan source files for risks
     */
    private async scanSourceFiles(): Promise<DetectedRisk[]> {
        const risks: DetectedRisk[] = [];
        const srcDir = path.join(this.workspaceRoot, 'src');
        
        // Scan src directory if it exists
        if (fs.existsSync(srcDir)) {
            await this.scanDirectory(srcDir, risks);
        }
        
        // Also scan root for config files
        await this.scanRootFiles(risks);
        
        return risks;
    }
    
    /**
     * Recursively scan a directory
     */
    private async scanDirectory(dir: string, risks: DetectedRisk[]): Promise<void> {
        try {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory()) {
                    // Skip common non-source directories
                    if (['node_modules', 'dist', 'build', 'out', '.git', 'coverage', '__pycache__', 'venv'].includes(entry.name)) {
                        continue;
                    }
                    await this.scanDirectory(fullPath, risks);
                } else if (entry.isFile()) {
                    // Only scan code files
                    if (/\.(ts|tsx|js|jsx|py|java|go|rs|rb|php|cs)$/.test(entry.name)) {
                        await this.scanFile(fullPath, risks);
                    }
                }
            }
        } catch (error) {
            console.warn(`[RiskDetector] Error scanning directory ${dir}:`, error);
        }
    }
    
    /**
     * Scan a single file for risks
     */
    private async scanFile(filePath: string, risks: DetectedRisk[]): Promise<void> {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const relativePath = path.relative(this.workspaceRoot, filePath);
            const lines = content.split('\n');
            
            // Check for sacred file markers
            for (const marker of SACRED_FILE_MARKERS) {
                if (content.includes(marker)) {
                    risks.push({
                        id: `sacred-${relativePath}`,
                        type: 'stability',
                        description: `File marked as "${marker}"`,
                        severity: 'strict',
                        file: relativePath,
                        suggestion: 'Do not modify this file - it is auto-generated or protected'
                    });
                    break;
                }
            }
            
            // Check for secrets
            for (const secretPattern of SECRET_PATTERNS) {
                const matches = content.match(secretPattern.pattern);
                if (matches) {
                    // Find line number
                    let lineNum = 1;
                    for (let i = 0; i < lines.length; i++) {
                        if (secretPattern.pattern.test(lines[i])) {
                            lineNum = i + 1;
                            break;
                        }
                    }
                    
                    // Reset regex lastIndex
                    secretPattern.pattern.lastIndex = 0;
                    
                    risks.push({
                        id: `secret-${secretPattern.name.toLowerCase().replace(/\s+/g, '-')}-${relativePath}`,
                        type: 'secret',
                        description: `Potential ${secretPattern.name} detected`,
                        severity: secretPattern.severity,
                        file: relativePath,
                        line: lineNum,
                        suggestion: 'Move to environment variables or secrets manager'
                    });
                }
            }
            
            // Check for risky patterns
            for (const riskyPattern of RISKY_CODE_PATTERNS) {
                // Reset regex lastIndex for global patterns
                riskyPattern.pattern.lastIndex = 0;
                
                const matches = content.match(riskyPattern.pattern);
                if (matches && matches.length > 0) {
                    // Find line number of first match
                    let lineNum = 1;
                    for (let i = 0; i < lines.length; i++) {
                        // Create a new regex for testing (to avoid lastIndex issues)
                        const testPattern = new RegExp(riskyPattern.pattern.source, riskyPattern.pattern.flags.replace('g', ''));
                        if (testPattern.test(lines[i])) {
                            lineNum = i + 1;
                            break;
                        }
                    }
                    
                    risks.push({
                        id: `risky-${riskyPattern.name.toLowerCase().replace(/\s+/g, '-')}-${relativePath}-${lineNum}`,
                        type: this.getRiskTypeForPattern(riskyPattern.name),
                        description: riskyPattern.description,
                        severity: riskyPattern.severity,
                        file: relativePath,
                        line: lineNum,
                        suggestion: riskyPattern.suggestion
                    });
                }
            }
        } catch (error) {
            // Silently skip files that can't be read
        }
    }
    
    /**
     * Scan root level files
     */
    private async scanRootFiles(risks: DetectedRisk[]): Promise<void> {
        const rootFiles = [
            'config.js',
            'config.ts',
            'config.json',
            '.env.example',
            'settings.js',
            'settings.json'
        ];
        
        for (const file of rootFiles) {
            const filePath = path.join(this.workspaceRoot, file);
            if (fs.existsSync(filePath)) {
                await this.scanFile(filePath, risks);
            }
        }
    }
    
    /**
     * Check for .env files
     */
    private checkEnvFiles(): DetectedRisk[] {
        const risks: DetectedRisk[] = [];
        
        const envFiles = [
            '.env',
            '.env.local',
            '.env.development',
            '.env.production',
            '.env.staging'
        ];
        
        for (const envFile of envFiles) {
            const envPath = path.join(this.workspaceRoot, envFile);
            if (fs.existsSync(envPath)) {
                risks.push({
                    id: `env-file-${envFile}`,
                    type: 'secret',
                    description: `Environment file ${envFile} exists - ensure it's in .gitignore`,
                    severity: 'warning',
                    file: envFile,
                    suggestion: 'Add to .gitignore if not already present'
                });
            }
        }
        
        return risks;
    }
    
    /**
     * Check .gitignore for common omissions
     */
    private checkGitignore(): DetectedRisk[] {
        const risks: DetectedRisk[] = [];
        const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
        
        if (!fs.existsSync(gitignorePath)) {
            risks.push({
                id: 'missing-gitignore',
                type: 'security',
                description: 'No .gitignore file found',
                severity: 'warning',
                suggestion: 'Create a .gitignore to prevent committing sensitive files'
            });
            return risks;
        }
        
        try {
            const content = fs.readFileSync(gitignorePath, 'utf-8');
            
            // Check for common patterns that should be ignored
            const shouldIgnore = [
                { pattern: '.env', message: '.env files' },
                { pattern: 'node_modules', message: 'node_modules' },
                { pattern: '*.log', message: 'log files' },
                { pattern: '.DS_Store', message: '.DS_Store' }
            ];
            
            for (const item of shouldIgnore) {
                if (!content.includes(item.pattern)) {
                    risks.push({
                        id: `gitignore-missing-${item.pattern.replace(/[^a-zA-Z0-9]/g, '-')}`,
                        type: 'security',
                        description: `.gitignore should include ${item.message}`,
                        severity: 'warning',
                        file: '.gitignore',
                        suggestion: `Add "${item.pattern}" to .gitignore`
                    });
                }
            }
        } catch (error) {
            // Ignore read errors
        }
        
        return risks;
    }
    
    /**
     * Determine risk type from pattern name
     */
    private getRiskTypeForPattern(patternName: string): DetectedRisk['type'] {
        const lowerName = patternName.toLowerCase();
        
        if (lowerName.includes('eval') || lowerName.includes('injection') || lowerName.includes('xss')) {
            return 'security';
        }
        if (lowerName.includes('console') || lowerName.includes('debugger')) {
            return 'maintainability';
        }
        if (lowerName.includes('any') || lowerName.includes('typescript')) {
            return 'maintainability';
        }
        if (lowerName.includes('global') || lowerName.includes('state')) {
            return 'stability';
        }
        
        return 'maintainability';
    }
    
    /**
     * Get reason string for a risk
     */
    private getReasonForRisk(risk: DetectedRisk): string {
        switch (risk.type) {
            case 'secret':
                return 'Exposing secrets in code can lead to security breaches';
            case 'security':
                return 'This pattern can introduce security vulnerabilities';
            case 'stability':
                return 'This pattern can cause unpredictable behavior or race conditions';
            case 'performance':
                return 'This pattern can cause performance issues';
            case 'maintainability':
                return 'This pattern makes code harder to maintain';
            default:
                return 'This pattern should be avoided for best practices';
        }
    }
    
    /**
     * Deduplicate similar risks
     */
    private deduplicateRisks(risks: DetectedRisk[]): DetectedRisk[] {
        const seen = new Map<string, DetectedRisk>();
        
        for (const risk of risks) {
            // Create a key based on type and description
            const key = `${risk.type}-${risk.description}`;
            
            const existing = seen.get(key);
            if (!existing) {
                seen.set(key, risk);
            } else {
                // Keep the more severe one
                const severityOrder: Record<EnforcementLevel, number> = {
                    'strict': 0,
                    'warning': 1,
                    'suggestion': 2
                };
                if (severityOrder[risk.severity] < severityOrder[existing.severity]) {
                    seen.set(key, risk);
                }
            }
        }
        
        return Array.from(seen.values());
    }
}

/**
 * Create a RiskDetector instance
 */
export function createRiskDetector(workspaceRoot: string): RiskDetector {
    return new RiskDetector(workspaceRoot);
}
